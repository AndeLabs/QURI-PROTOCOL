/**
 * NFT.Storage Integration (Enterprise-grade IPFS)
 * 
 * Why NFT.Storage?
 * - Used by OpenSea, Blur, Foundation, Rarible
 * - 100% FREE forever (sponsored by Filecoin Foundation)
 * - Permanent storage (Filecoin deals)
 * - No file size limits
 * - Global CDN
 * - Enterprise reliability
 * 
 * Setup:
 * 1. Get API key: https://nft.storage/
 * 2. Add to .env.local: NEXT_PUBLIC_NFT_STORAGE_API_KEY=xxx
 */

import { NFTStorage, File, Blob } from 'nft.storage';
import { logger } from '@/lib/logger';

export interface IPFSUploadResult {
  ipfsHash: string;
  ipfsUrl: string;
  gatewayUrl: string;
  size: number;
}

export interface RuneMetadata {
  name: string;
  symbol: string;
  description?: string;
  image: string; // IPFS URL
  external_url?: string;
  attributes?: Array<{
    trait_type: string;
    value: string | number;
  }>;
  properties?: {
    supply: string;
    divisibility: number;
    creator: string;
    blockHeight?: number;
    mint_amount?: string;
    mint_cap?: string;
  };
}

/**
 * Validate NFT.Storage API key format
 */
function validateAPIKey(apiKey: string): { valid: boolean; error?: string } {
  // JWT tokens have 3 parts separated by dots
  const parts = apiKey.split('.');
  
  if (parts.length !== 3) {
    return {
      valid: false,
      error: `Invalid JWT format. Expected 3 parts (header.payload.signature), got ${parts.length}. Please copy the COMPLETE API key from https://nft.storage`,
    };
  }

  // Each part should be base64url encoded (alphanumeric, -, _)
  const base64urlRegex = /^[A-Za-z0-9_-]+$/;
  
  for (let i = 0; i < parts.length; i++) {
    if (!base64urlRegex.test(parts[i])) {
      return {
        valid: false,
        error: `Invalid characters in JWT part ${i + 1}. API key must be base64url encoded.`,
      };
    }
  }

  // Header should decode to JSON with "alg" field
  try {
    const headerJson = atob(parts[0].replace(/-/g, '+').replace(/_/g, '/'));
    const header = JSON.parse(headerJson);
    
    if (!header.alg || !header.typ) {
      return {
        valid: false,
        error: 'Invalid JWT header. Missing "alg" or "typ" fields.',
      };
    }
  } catch (e) {
    return {
      valid: false,
      error: 'Failed to decode JWT header. API key appears to be corrupted.',
    };
  }

  // Signature should be at least 32 characters (base64url encoded HMAC)
  if (parts[2].length < 32) {
    return {
      valid: false,
      error: `JWT signature too short (${parts[2].length} chars). Expected ~43 characters for HS256. Please copy the COMPLETE API key.`,
    };
  }

  return { valid: true };
}

/**
 * Initialize NFT.Storage client
 */
function getNFTStorageClient(): NFTStorage | null {
  const apiKey = process.env.NEXT_PUBLIC_NFT_STORAGE_API_KEY;
  
  if (!apiKey) {
    logger.warn('NFT.Storage API key not configured');
    return null;
  }

  // Validate API key format
  const validation = validateAPIKey(apiKey);
  if (!validation.valid) {
    logger.error('NFT.Storage API key validation failed', { error: validation.error });
    throw new Error(`NFT.Storage API Key Error: ${validation.error}`);
  }
  
  return new NFTStorage({ token: apiKey });
}

/**
 * Upload file to NFT.Storage (IPFS + Filecoin)
 */
export async function uploadToNFTStorage(file: File): Promise<IPFSUploadResult> {
  try {
    logger.info('Uploading file to NFT.Storage', {
      name: file.name,
      size: file.size,
      type: file.type,
    });

    const client = getNFTStorageClient();
    
    if (!client) {
      logger.warn('NFT.Storage not configured, using mock upload');
      return mockIPFSUpload(file);
    }

    // Convert browser File to NFT.Storage File
    const arrayBuffer = await file.arrayBuffer();
    const nftFile = new File([arrayBuffer], file.name, { type: file.type });

    // Upload to NFT.Storage (automatically pins to IPFS + Filecoin)
    const cid = await client.storeBlob(new Blob([arrayBuffer]));

    const result: IPFSUploadResult = {
      ipfsHash: cid,
      ipfsUrl: `ipfs://${cid}`,
      // Use multiple gateways for redundancy
      gatewayUrl: `https://nftstorage.link/ipfs/${cid}`,
      size: file.size,
    };

    logger.info('File uploaded to NFT.Storage successfully', { 
      cid,
      filecoinDeals: 'pending', // NFT.Storage creates Filecoin deals automatically
    });

    return result;
  } catch (error) {
    // Enhanced error handling with specific messages
    if (error instanceof Error) {
      // Check for authentication errors
      if (error.message.includes('401') || error.message.includes('Unauthorized') || error.message.includes('malformed')) {
        logger.error('NFT.Storage authentication failed', error);
        throw new Error(
          'üîë Error de Autenticaci√≥n NFT.Storage\n\n' +
          'El API key es inv√°lido o est√° incompleto.\n\n' +
          'üìã Pasos para solucionarlo:\n' +
          '1. Ve a https://nft.storage y accede a tu cuenta\n' +
          '2. Click en "API Keys" en el men√∫\n' +
          '3. Copia el token COMPLETO (debe ser muy largo, 200+ caracteres)\n' +
          '4. P√©galo en .env.local como NEXT_PUBLIC_NFT_STORAGE_API_KEY\n' +
          '5. Reinicia el servidor (npm run dev)\n\n' +
          `Detalles t√©cnicos: ${error.message}`
        );
      }

      // Check for network errors
      if (error.message.includes('fetch') || error.message.includes('network')) {
        logger.error('Network error during NFT.Storage upload', error);
        throw new Error(
          'üåê Error de Conexi√≥n\n\n' +
          'No se pudo conectar con NFT.Storage. Verifica tu conexi√≥n a internet.\n\n' +
          `Detalles: ${error.message}`
        );
      }

      // Check for file size errors
      if (error.message.includes('size') || error.message.includes('large')) {
        logger.error('File too large for NFT.Storage', error);
        throw new Error(
          'üì¶ Archivo Demasiado Grande\n\n' +
          'El archivo supera el l√≠mite permitido. Intenta con una imagen m√°s peque√±a.\n\n' +
          `Detalles: ${error.message}`
        );
      }
    }

    logger.error('Failed to upload to NFT.Storage', error instanceof Error ? error : undefined);
    throw error;
  }
}

/**
 * Upload JSON metadata to NFT.Storage
 */
export async function uploadMetadataToNFTStorage(
  metadata: RuneMetadata
): Promise<IPFSUploadResult> {
  try {
    logger.info('Uploading metadata to NFT.Storage', { name: metadata.name });

    const client = getNFTStorageClient();
    
    if (!client) {
      logger.warn('NFT.Storage not configured, using mock upload');
      return mockMetadataUpload(metadata);
    }

    // Convert metadata to JSON blob
    const jsonString = JSON.stringify(metadata, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });

    // Upload to NFT.Storage
    const cid = await client.storeBlob(blob);

    const result: IPFSUploadResult = {
      ipfsHash: cid,
      ipfsUrl: `ipfs://${cid}`,
      gatewayUrl: `https://nftstorage.link/ipfs/${cid}`,
      size: jsonString.length,
    };

    logger.info('Metadata uploaded to NFT.Storage successfully', { cid });

    return result;
  } catch (error) {
    logger.error('Failed to upload metadata to NFT.Storage', error instanceof Error ? error : undefined);
    throw error;
  }
}

/**
 * Upload image and create metadata in one go
 * This is the main function to use
 */
export async function uploadRuneAssets(
  imageFile: File,
  metadata: Omit<RuneMetadata, 'image'>
): Promise<{ imageUpload: IPFSUploadResult; metadataUpload: IPFSUploadResult }> {
  try {
    logger.info('Starting Rune assets upload to NFT.Storage', {
      imageName: imageFile.name,
      runeName: metadata.name,
    });

    // Step 1: Upload image to NFT.Storage
    const imageUpload = await uploadToNFTStorage(imageFile);

    // Step 2: Create full metadata with image URL
    // Use multiple gateways for maximum availability
    const fullMetadata: RuneMetadata = {
      ...metadata,
      image: imageUpload.ipfsUrl, // Use ipfs:// protocol (best practice)
    };

    // Step 3: Upload metadata to NFT.Storage
    const metadataUpload = await uploadMetadataToNFTStorage(fullMetadata);

    logger.info('Rune assets uploaded successfully', {
      imageHash: imageUpload.ipfsHash,
      metadataHash: metadataUpload.ipfsHash,
      storage: 'NFT.Storage (IPFS + Filecoin)',
      permanence: 'Guaranteed via Filecoin deals',
    });

    return { imageUpload, metadataUpload };
  } catch (error) {
    logger.error('Failed to upload rune assets', error instanceof Error ? error : undefined);
    throw error;
  }
}

/**
 * Convert IPFS URL to gateway URL
 * Supports multiple gateways for redundancy
 */
export function ipfsToGatewayUrl(ipfsUrl: string, gateway: 'nftstorage' | 'ipfs' | 'cloudflare' | 'pinata' | 'dweb' = 'nftstorage'): string {
  if (!ipfsUrl.startsWith('ipfs://')) {
    return ipfsUrl; // Already a gateway URL
  }

  const hash = ipfsUrl.replace('ipfs://', '');

  const gateways = {
    nftstorage: `https://nftstorage.link/ipfs/${hash}`,      // NFT.Storage CDN (fastest)
    ipfs: `https://ipfs.io/ipfs/${hash}`,                     // Public IPFS gateway
    cloudflare: `https://cloudflare-ipfs.com/ipfs/${hash}`,  // Cloudflare CDN
    pinata: `https://gateway.pinata.cloud/ipfs/${hash}`,     // Pinata gateway
    dweb: `https://dweb.link/ipfs/${hash}`,                   // Protocol Labs gateway
  };

  return gateways[gateway];
}

/**
 * Get multiple gateway URLs for redundancy
 * Frontend can try these in order if one fails
 */
export function getMultipleGatewayUrls(ipfsUrl: string): string[] {
  const hash = ipfsUrl.replace('ipfs://', '');
  
  return [
    `https://nftstorage.link/ipfs/${hash}`,         // Primary: NFT.Storage
    `https://cloudflare-ipfs.com/ipfs/${hash}`,     // Backup 1: Cloudflare
    `https://dweb.link/ipfs/${hash}`,               // Backup 2: Protocol Labs
    `https://ipfs.io/ipfs/${hash}`,                 // Backup 3: Public gateway
  ];
}

/**
 * Mock upload for development without NFT.Storage credentials
 */
function mockIPFSUpload(file: File): IPFSUploadResult {
  const mockHash = `bafybei${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`;

  logger.info('Using MOCK NFT.Storage upload (development mode)', {
    file: file.name,
    mockHash,
  });

  return {
    ipfsHash: mockHash,
    ipfsUrl: `ipfs://${mockHash}`,
    gatewayUrl: `https://nftstorage.link/ipfs/${mockHash}`,
    size: file.size,
  };
}

/**
 * Mock metadata upload for development
 */
function mockMetadataUpload(metadata: RuneMetadata): IPFSUploadResult {
  const mockHash = `bafybei${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`;

  logger.info('Using MOCK NFT.Storage metadata upload (development mode)', {
    name: metadata.name,
    mockHash,
  });

  return {
    ipfsHash: mockHash,
    ipfsUrl: `ipfs://${mockHash}`,
    gatewayUrl: `https://nftstorage.link/ipfs/${mockHash}`,
    size: JSON.stringify(metadata).length,
  };
}

/**
 * Validate image file
 */
export function validateImageFile(file: File): { valid: boolean; error?: string } {
  // Check file type
  const validTypes = [
    'image/jpeg',
    'image/jpg',
    'image/png',
    'image/gif',
    'image/webp',
    'image/svg+xml',
  ];
  
  if (!validTypes.includes(file.type)) {
    return {
      valid: false,
      error: 'Invalid file type. Please upload JPEG, PNG, GIF, WebP, or SVG.',
    };
  }

  // Check file size (NFT.Storage allows up to 100GB, but we'll limit to 50MB for UX)
  const maxSize = 50 * 1024 * 1024; // 50MB
  if (file.size > maxSize) {
    return {
      valid: false,
      error: 'File too large. Maximum size is 50MB.',
    };
  }

  return { valid: true };
}

/**
 * Check if content is available on IPFS
 */
export async function checkIPFSAvailability(ipfsHash: string): Promise<{
  available: boolean;
  gateways: { url: string; status: 'ok' | 'error' }[];
}> {
  const gateways = getMultipleGatewayUrls(`ipfs://${ipfsHash}`);
  
  const results = await Promise.all(
    gateways.map(async (url) => {
      try {
        const response = await fetch(url, { method: 'HEAD' });
        return { url, status: response.ok ? 'ok' : 'error' } as const;
      } catch {
        return { url, status: 'error' } as const;
      }
    })
  );

  const available = results.some(r => r.status === 'ok');

  return { available, gateways: results };
}

/**
 * Get storage status from NFT.Storage API
 */
export async function getStorageStatus(cid: string): Promise<{
  cid: string;
  size?: number;
  created?: string;
  deals?: Array<{
    provider: string;
    status: string;
  }>;
}> {
  try {
    const apiKey = process.env.NEXT_PUBLIC_NFT_STORAGE_API_KEY;
    
    if (!apiKey) {
      throw new Error('NFT.Storage API key not configured');
    }

    const response = await fetch(`https://api.nft.storage/check/${cid}`, {
      headers: {
        Authorization: `Bearer ${apiKey}`,
      },
    });

    if (!response.ok) {
      throw new Error(`NFT.Storage API error: ${response.statusText}`);
    }

    const data = await response.json();
    return data.value;
  } catch (error) {
    logger.error('Failed to get storage status', error instanceof Error ? error : undefined);
    return { cid };
  }
}
